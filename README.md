
# 1. Какой самый эффективный способ конкатенации строк?
### a) Нативная конкатенация (+)
```go
var s string
s += "hello"
```
Метод нативной конкатенации использует оператор "+" для непосредственного объединения двух строк. В коде используется "+=", чтобы объединить и переназначить строки.  

Этот подход неэффективен, потому что строка в Golang является неизменяемой, значение s должно быть сначала взято (скопировано сверху), затем объединено со строкой, и затем новое значение (совершенно новая строка) снова присваивается s после вычисления, в то время как старое значение s будет ожидать сборщика мусора. Поскольку каждое объединение итеративно копируется с начала, это требует больше вычислений и выделения памяти.  Временная сложность этого подхода составляет $O(N^2)$.

### b) bytes.Buffer
Buffer — это байтовый буфер переменной длины. Он использует `buf []byte` внутри для хранения байтов.
```go
buf := bytes.NewBufferString("hello")
buf.WriteString(" world") // fmt.Fprint(buf, " world")
```
При использовании WriteString для конкатенации строк он динамически увеличивает длину среза в соответствии с ситуацией и копирует строку для сращивания в буфер с помощью встроенной функции копирования памяти срезов. Поскольку это срез переменной длины, при каждом сращивании не нужно повторно копировать старую часть, а только добавлять часть, которую нужно соединить, в конец, поэтому он имеет более высокую производительность, чем нативный метод конкатенации.

Временная сложность этого метода составляет $O(N)$.
```go
// WriteString appends the contents of s to the buffer, growing the buffer as
// needed. The return value n is the length of s; err is always nil. If the
// buffer becomes too large, WriteString will panic with ErrTooLarge.
func (b *Buffer) WriteString(s string) (n int, err error) {
    b.lastRead = opInvalid
    m, ok := b.tryGrowByReslice(len(s))
    if !ok {
        m = b.grow(len(s))
    }
    return copy(b.buf[m:], s), nil
}
```

### d) strings.Builder

`strings.Builder` также использует байтовый срез внутри для хранения.

```go
var builder strings.Builder
builder.WriteString("hello") // fmt.Fprint(&builder, "hello")

```

При использовании WriteString для сшивания строк вызывается встроенная функция append, и в буфер объединяется только строка, которую нужно сшить.
```go
// WriteString appends the contents of s to b's buffer.
// It returns the length of s and a nil error.
func (b *Builder) WriteString(s string) (int, error) {
    b.copyCheck()
    b.buf = append(b.buf, s...)
    return len(s), nil
}

```

### d) Встроенная функция копирования (copy)
Встроенная функция копирования поддерживает копирование исходного среза в целевой срез, и, поскольку базовым представлением строки является []byte, эту функцию также можно использовать для конкатенации строк. Однако ограничение заключается в том, что длина байтового среза должна быть известна заранее.
```go
bytes := make([]byte, 11)
size := copy(bytes[0:], "hello")
copy(bytes[size:], " world")
fmt.Println(string(bytes))
```
Встроенная функция копирования поддерживает копирование из одного среза в другой (она поддерживает копирование строки в ), а возвращаемым значением является длина скопированного элемента.

Возвращаемое значение — это длина копируемого элемента. Каждый раз, когда он сращивается, ему нужно только добавить строку, которую нужно соединить, к концу среза, что также очень эффективно.
```go
// The copy built-in function copies elements from a source slice into a
// destination slice. (As a special case, it also will copy bytes from a
// string to a slice of bytes.) The source and destination may overlap. Copy
// returns the number of elements copied, which will be the minimum of
// len(src) and len(dst).
func copy(dst, src []Type) int
```

### e) strings.Join
Чтобы поместить части строкового среза `[]string` в одну строку, вы можете использовать для этого `strings.Join`.
```go
s := strings.Join([]string{"hello world"}, "")
```

Его внутренняя реализация также выполняется с помощью байтов. Так что это тоже очень эффективно.
```go
// Join concatenates the elements of its first argument to create a single string. The separator
// string sep is placed between elements in the resulting string.
func Join(elems []string, sep string) string {
    ...
    var b Builder
    b.Grow(n)
    b.WriteString(elems[0])
    for _, s := range elems[1:] {
        b.WriteString(sep)
        b.WriteString(s)
    }
    return b.String()
}
```

## Бенчмаркинг
```go
package string_test

import (
    "bytes"
    "strings"
    "testing"
)

var (
    concatSteps = 1000
    subStr      = "s"
    expectedStr = strings.Repeat(subStr, concatSteps)
)

func BenchmarkConcat(b *testing.B) {
    for n := 0; n < b.N; n++ {
        var s string
        for i := 0; i < concatSteps; i++ {
            s += subStr
        }
        if s != expectedStr {
            b.Errorf("unexpected result, got: %s, want: %s", s, expectedStr)
        }
    }
}

func BenchmarkBuffer(b *testing.B) {
    for n := 0; n < b.N; n++ {
        var buffer bytes.Buffer
        for i := 0; i < concatSteps; i++ {
            buffer.WriteString(subStr)
        }
        if buffer.String() != expectedStr {
            b.Errorf("unexpected result, got: %s, want: %s", buffer.String(), expectedStr)
        }
    }
}

func BenchmarkBuilder(b *testing.B) {
    for n := 0; n < b.N; n++ {
        var builder strings.Builder
        for i := 0; i < concatSteps; i++ {
            builder.WriteString(subStr)
        }
        if builder.String() != expectedStr {
            b.Errorf("unexcepted result, got: %s, want: %s", builder.String(), expectedStr)
        }
    }
}

func BenchmarkCopy(b *testing.B) {
    for n := 0; n < b.N; n++ {
        bytes := make([]byte, len(subStr)*concatSteps)
        c := 0
        for i := 0; i < concatSteps; i++ {
            c += copy(bytes[c:], subStr)
        }
        if string(bytes) != expectedStr {
            b.Errorf("unexpected result, got: %s, want: %s", string(bytes), expectedStr)
        }
    }
}
```

```sh
$ go test -benchmem -bench .

goos: darwin
goarch: amd64
pkg: github.com/olzhy/test
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkConcat-4           7750            148143 ns/op          530274 B/op        999 allocs/op
BenchmarkBuffer-4         161848              7151 ns/op            3248 B/op          6 allocs/op
BenchmarkBuilder-4        212043              5406 ns/op            2040 B/op          8 allocs/op
BenchmarkCopy-4           281827              4208 ns/op            1024 B/op          1 allocs/op
PASS
ok      github.com/olzhy/test   5.773s
```

Из этого следует, что встроенная функция копирования с strings.Builder - это самые эффективные способы.
 
# 2. Что такое интерфейсы, как они применяются в Go?
Интерфейсный тип в Go — это своего рода _определение_. Он определяет и описывает конкретные методы, которые должны быть у _какого-то другого типа_.

Одним из интерфейсных типов из стандартной библиотеки является интерфейс [fmt.Stringer](https://golang.org/pkg/fmt/#Stringer):  
```go
type Stringer interface {
    String() string
}
``` 
Мы говорим, что «что-то» _удовлетворяет этому интерфейсу_ (или _реализует этот интерфейс_), если у этого «что-то» есть метод с конкретным сигнатурным строковым значением `String()`.  

Например, тип `Book` удовлетворяет интерфейсу, потому что у него есть строковый метод `String()`:  
```go
type Book struct {
    Title  string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}
```
Неважно, каким типом является `Book` или что он делает. Важно лишь, что у него есть метод под названием `String()`, который возвращает строковое значение.  
  
А вот другой пример. Тип `Count` тоже _удовлетворяет интерфейсу_  `fmt.Stringer`, потому что у него есть метод с тем же сигнатурным строковым значением `String()`.  
```go
type Count int

func (c Count) String() string {
    return strconv.Itoa(int(c))
}
```
Здесь важно понять, что у нас есть два разных типа `Book` и `Count`, которые действуют по-разному. Но их объединяет то, что они оба удовлетворяют интерфейсу `fmt.Stringer`.  
  
Можно посмотреть на это с другой стороны. Если объект удовлетворяет интерфейсу `fmt.Stringer`, то можно считать, что у него есть метод с сигнатурным строковым значением `String()`, которое можно вызывать.  
  
_Когда в Go объявляется переменная, параметр функции или поле структуры, имеющее интерфейсный тип, можно использовать объект любого типа, пока он удовлетворяет интерфейсу._  

Допустим, есть функция:  
```go
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}
```

Поскольку `WriteLog()` использует в объявлении параметра интерфейсный тип `fmt.Stringer`, можно передавать любой объект, удовлетворяющий интерфейсу `fmt.Stringer`. Например, можно передать типы `Book` и `Count` и код будет нормально работать.  
  
Кроме того, поскольку передаваемый объект удовлетворяет интерфейсу `fmt.Stringer`, мы _знаем_, что у него есть строковый метод `String()`, который может быть безопасно вызван функцией `WriteLog()`.

Используя интерфейсный тип в объявлении функции `WriteLog()`, была создана функция безразличной (или гибкой) к _типу_ принимаемого объекта. Важно лишь то, _какие у него методы_.

Все типы реализуют по крайней мере ноль методов, и удовлетворение интерфейса выполняется автоматически, все типы удовлетворяют пустой интерфейс. Следовательно, метод с пустым интерфейсом в качестве аргумента может принимать любой тип.

**Полезность интерфейсов:**
1.  Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
2.  Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
3.  Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.

# 3. Чем отличаются RWMutex от Mutex?
`RWMutex` нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. 

Например, стандартный тип `map`. Перед записью в защищаемый мьютексом объект делается `.Lock()`, а вызовы `.Lock()` и `.RLock()` в других горутинах будут ждать, пока вы не отпустите мьютекс через `.Unlock()`. 

Перед чтением защищаемого объекта делается `.RLock()` и только вызовы `.Lock()` в других горутинах блокируются, вызовы `.RLock()` спокойно проходят. Когда отпускаете мьютекс через `.RUnlock()`, ждущие вызовы `.Lock()` по очереди могут забирать мьютекс на себя. Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

# 4. Чем отличаются буферизированные и не буферизированные каналы?
При создании канала мы можем указать/ не указать третий аргумент - размер буфера канала
```go
// небуферизованный канал целых чисел
ci := make(chan int)

// небуферизованный канал целых чисел            
cj := make(chan int, 0)   
     
// буферизованный канал целых чисел 
ck := make(chan int, 100)  
```
Приемники всегда блокируются, пока нет данных для приема. 

Если канал не буферизован, отправитель блокируется, пока получатель не получил значение.

Если у канала есть буфер, отправитель блокируется только до того, как значение будет скопировано в буфер, если буфер заполнен, это означает ожидание, пока какой-либо получатель не получит значение.

# 5. Какой размер у структуры struct{}{}?
Структура представляет собой последовательность именованных элементов, называемых полями, каждая из которых имеет имя и тип. Пустая структура не имеет полей, вроде этой пустой структуры:
```go
var s struct{}
```
Интересная вещь о пустой структуре состоит в том, что ее размер равен нулю.
```go
fmt.Println(unsafe.Sizeof(s))
```
Это печатает `0` , поэтому пустая структура сама по себе не занимает памяти, поэтому это хороший вариант, например, для выхода из канала.
```go
func main() {
    done := make(chan struct{})
    go func() {
        time.Sleep(5 * time.Second)
        close(done)
    }()

    fmt.Println("Wait...")
    <-done
    fmt.Println("done.")
}
```

# 6. Есть ли в Go перегрузка методов или операторов?
> Диспетчеризация методов упрощается, если не нужно также выполнять
> сопоставление типов. Опыт работы с другими языками подсказывал нам,
> что наличие множества методов с одинаковыми именами, но разными
> сигнатурами иногда бывает полезно, но на практике это также может быть
> запутанным и хрупким. Сопоставление только по имени и требование
> согласованности в типах было основным упрощающим решением в системе
> типов Go.
> 
> Что касается перегрузки оператора, то это скорее удобство, чем
> абсолютное требование. Опять же, без него все проще.  
> [Оригинал](https://golang.org/doc/faq#overloading)

В Golang нет перегрузки операторов в традиционном смысле, как в некоторых других языках. Вместо этого Golang предоставляет возможность определения методов с определенными именами, которые могут использоваться для симуляции поведения операторов.

Например, для работы с числовыми типами данных можно определить методы Add, Sub, Mul, Div и т.д. и использовать их для выполнения арифметических операций. Для работы с массивами или слайсами можно определить методы Len, Less, Swap и т.д. и использовать их для сортировки.

Также в Golang существует возможность определения пользовательских типов и их методов, что позволяет создавать более читаемый и понятный код.

# 7. В какой последовательности будут выведены элементы map[int]int?
Рассмотрим следующую программу:  
```go
package main

import "fmt"

func main() {
	m := map[int]int{}
	for i := 0; i < 5; i++ {
		m[i] = (i % 2)
	}
	for k, v := range m {
		fmt.Printf("key: %d, value: %d\n", k, v)
	}
}
```
Запуск 1:  
```
key: 3, value: 1
key: 4, value: 0
key: 0, value: 0
key: 1, value: 1
key: 2, value: 0
```
Запуск 2:  
```
key: 4, value: 0
key: 0, value: 0
key: 1, value: 1
key: 2, value: 0
key: 3, value: 1
```
Как видим, вывод разнится от запуска к запуску. Все потому, что мапа в Go unordered, то есть неупорядоченная. Это значит, что полагаться на порядок при обходе не надо. Причину можно найти в исходном коде рантайма языка:  
```go
// mapiterinit initializes the hiter struct used for ranging over maps. 
func mapiterinit(t *maptype, h *hmap, it *hiter) {...
// decide where to start 
r := uintptr(fastrand())
... 
it.startBucket = r & bucketMask(h.B)...}
```
Место поиска определяется рандомно.

# 8. В чем разница make и new?
**make** и **new** – это встроенные механизмы для выделения памяти. Они используются в разных ситуациях и имеют свои особенности:
- **new**  инициализирует нулевое значение для данного типа и возвращает указатель на этот тип.
- **make**  используется исключительно для создания и инициализации срезов, отображений и каналов, возвращает ненулевой экземпляр указанного типа.

Основное отличие между ними состоит в том, что  **make**  возвращает инициализированный тип, готовый к использованию после создания, а  **new**  – указатель на тип с его нулевым значением.

# 9. Сколько существует способов задать переменную типа slice или map?
- С помощью функции `make`, например 
```go
m := make(map[int]int)
```
- С помощью инициализации, например 
```go
m := map[int]int{1: 2, 2: 3}
``` 
или 
```go
var m = map[int]int{1: 2, 2: 3}
```
- С помощью определения переменной, например 
```go
var m map[int]int
```
- С помощью new:
```go
m := new(map[int]int)
```

**НО!** Последние 2 способа почти неприменимы на практике, так как типы map
являются ссылочными типами, такими как указатели или срезы (slice), и поэтому значение равно nil; оно не указывает на инициализированную карту. Нулевая карта (nil map) ведет себя как пустая карта при чтении, но попытки записи в нулевую карту вызовут панику во время выполнения (runtime panic). 

# 10. Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

```
**Ответ:**
У каждой переменной есть значение и адрес памяти (ссылку на ячейку памяти)

В функции main создается две переменных: a типа int, p типа *int.

Обозначим, что адрес памяти (ссылка на ячейку памяти) переменной a равен x,
адрес памяти (ссылка на ячейку памяти) переменной p равен y. Тогда так как
переменная p имеет тип *int, то ее значение равно x.

Функция update принимает на вход переменную p типа *int, в теле функции создана
также переменная b типа int.

Обозначим, что адрес памяти (ссылка на ячейку памяти) переменной b равен z.
Далее значение переменной p меняется на z.

Исходя из названия и тела функции, ожидался вывод:
1
2

Но так как при передаче в функцию update переменной p создалась копия с тем же значением,
но с другим адресом памяти (ссылкой на ячейку памяти), то в функции main значение переменной p не изменилось, а значит после вызова update, при разыменовывании будет получено:
1
1

Для получения ожидаемого результата:
```go
func update(p **int) {
  b := 2
  *p = &b
}

func main() {
  var (
    a = 1
    p = &a
  )

  fmt.Println(*p)
  update(&p)
  fmt.Println(*p)
}
```

# 11. Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
**Ответ:**
Исходя из тела функции, ожидался вывод числа от 0 до 4 в произвольном порядке, затем "exit".

На самом деле мы добьемся: "fatal error: all goroutines are asleep - deadlock!" в момент ожидания завершения работы всех горутин, так как в созданные горутины мы передаем копию wg по значению,
соответственно при декрементировании (wg.Done()), мы не добьемся уменьшения счетчика внешнего wg.

Для получения ожидаемого вывода:
```go
func main() {
	wg := sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)

		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(&wg, i)
	}

	wg.Wait()
	fmt.Println("exit")
}
```

# 12. Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
**Ответ:**
Исходя из тела функции, ожидался вывод:
2

Области видимости ограничены {}, значит у нас есть область видимости функции main и
вложенная область видимости if.

Когда код ссылается на переменные, он всегда сначала находит переменную в
текущей области видимости (не содержащем никаких вложенных областей видимости).
Если в текущей области видимости не объявлена переменная с таким именем,
программа будет искать слой за слоем по отношению вложенности блока кода.

Так в блоке if объявлена переменная n, то значение 1, а затем инкрементирование этой
переменной относится только к блоку if.

Для ожидаемого вывода:
```go
func main() {
	n := 0

	if true {
		n = 1
		n++
	}

	fmt.Println(n)
}
```

# 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
**Ответ:**
Исходя из тела функции, ожидался вывод:
[1 2 3 4 5]
[100 2 3 4 5 6]

В теле функции мы создаем слайс a. Первый fmt.Println(a) выведет нам значения исходного слайса ([1 2 3 4 5]).

Слайс под капотом является структурой, которая содержит ссылку на исходный массив, длину и вместимость:
```go
struct {
	array *[]T
	length int
	capacity int
}
```

Так как мы создавали слайс без указания capacity, то оно по умолчанию стало равно length, это значит,
что массив array, который создался под капотом уже весь заполнен.

При передаче a в функцию someAction, создается точная копия a (v), но так как значение переменной array -
это ссылка на исходный (созданный под капотом массив), то при изменении значения первого элемента у "v",
изменится значение первого элемента и у "a".

При передаче v в append исходный массив изменится на другой, так как length = capacity,
но он изменится у v (точной копии a). Значит при повторном fmt.Println(a) выведется:
[100 2 3 4 5]

Для ожидаемого вывода:
```go
func someAction(v *[]int8, b int8) {
  (*v)[0] = 100
  *v = append(*v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  fmt.Println(a)
  someAction(&a, 6)
  fmt.Println(a)
}
```

# 14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

```
**Ответ:**
Объяснение происходящего - в предыдущем задании

Ожидался вывод:
[b b a][b b a]

Вывод:
[b b a][a a]

Между выведенными на экран массивами нет переноса на следующую строку, так как использовалась fmt.Print,
вместо fmt.Println

Для ожидаемого вывода:
```go
func main() {
	slice := []string{"a", "a"}

	func(slice *[]string) {
		*slice = append(*slice, "a")
		(*slice)[0] = "b"
		(*slice)[1] = "b"
		fmt.Print(*slice)
	}(&slice)

	fmt.Print(slice)
}
```

или

```go
func main() {
	slice := []string{"a", "a"}

	func() {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}()

	fmt.Print(slice)
}
```

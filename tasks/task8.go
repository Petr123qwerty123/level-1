package tasks

/*
Представим числа в десятичной СС в следующем виде:

Например, uint8 ________, где каждая "_" для записи 0 или 1, под каждой "_" мысленно запишем 2 в степени индекса "_",
где индексы начинаются справа и с нуля (128, 64, 32, 16, 8, 4, 2, 1) - это множители для битов, записанных над "_"

Таким образом,
2 -> 00000010 (128*0 + 64*0 + 32*0 + 16*0 + 8*0 + 4*0 + 2*1 + 1*0 = 2),
3 -> 00000011 (128*0 + 64*0 + 32*0 + 16*0 + 8*0 + 4*0 + 2*1 + 1*1 = 3)

Побитовый сдвиг обозначает, что мы как бы сдвигаем с "_" биты влево или вправо, и там где на "_" не осталось битов мы
записываем 0

Пример для побитового сдвига влево на 2 для 2:
2 << 2 -> 000010__ = 00001000 (128*0 + 64*0 + 32*0 + 16*0 + 8*1 + 4*0 + 2*0 + 1*0 = 8)

Операция побитного умножения (&):
0 0 0
0 1 0
1 0 0
1 1 0

Операция побитного сложения (|):
0 0 0
0 1 1
1 0 1
1 1 1

Операция логического отрицания (^):
0 1
1 0

Если требуется установить какой-то бит в единицу, требуется создать маску побитным сдвигом единицы влево на
индекс того бита, который мы хотим установить в числе, после этого побитно сложить исходное число с маской
Таким образом, если в числе бит был равен 0, то при сложении он обратиться в 0, остальные биты не изменяться, так как
это побитное сложение; если в числе бит был равен 1, то при сложении он не измениться, исходя из таблицы истинности

Если требуется установить какой-то бит в ноль, требуется создать маску побитным сдвигом единицы влево на
индекс того бита, который мы хотим установить в числе, затем инвертировать (изменить все 0 на 1, 1 на 0)
после этого побитно перемножить исходное число с маской
Таким образом, если в числе бит был равен 0, то при умножении он не измениться, как и остальные биты, так как они
были помножены на 1; если в числе бит был равен 1, то при умножении он измениться на 0, остальные биты не изменяться.
*/

func Task8(x int64, i uint8, bitValue uint8) int64 {
	mask := int64(1) << i

	if bitValue == 1 {
		x |= mask
	} else {
		x &= ^mask
	}

	return x
}
